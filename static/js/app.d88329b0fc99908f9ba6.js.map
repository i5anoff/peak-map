{"version":3,"sources":["webpack:///./src/appState.js","webpack:///./src/lib/createHeightMapRenderer.js","webpack:///./src/config.js","webpack:///./src/elevation.js","webpack:///./src/main.js"],"names":["appState","angle","currentState","lineDensity","smoothSteps","mapOpacity","heightScale","oceanLevel","aboutVisible","blank","error","zazzleLink","startOver","generatingPreview","downloadOsmProgress","settingsOpen","shouldDraw","showPrintMessage","renderProgress","hidePrintMessageForSession","width","window","innerWidth","height","innerHeight","backgroundColor","r","g","b","a","lineBackground","lineColor","createHeightMapRenderer","regionInfo","canvas","renderHandle","render","cancel","cancelAnimationFrame","message","parse_float_default","parseFloat","style","opacity","ctx","getContext","lineStroke","getColor","lineFill","resHeight","resWidth","rowCount","Math","round","scale","_regionInfo$getAllHei","getAllHeightData","minHeight","maxHeight","rowWithHighestPoint","iteratorSettings","includeRowIndex","stepSize","start","floor","step","stop","createRegionIterator","heightRange","lastLine","lastRow","drawPolyLine","points","length","smoothRange","windowSize","result","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","i","leftOffset","from","to","count","sum","j","smoothHeight","getSmoothRange","beginPath","fillStyle","moveTo","lineTo","closePath","fill","strokeStyle","stroke","clearRect","fillRect","renderRows","now","performance","y","x","getHeightAtPoint","fY","push","elapsed","requestAnimationFrame","color","MAPBOX_TOKEN","apiURL","getRegionElevation","map","progress","doneCallback","tileSize","tileZoom","transform","zoomPower","pow","coveringTiles","minzoom","maxzoom","tileBounds","reduce","bounds","tile","p","canonical","minX","minY","maxX","maxY","Infinity","document","createElement","Error","total","advanceProgress","heightsHandle","isCancelled","tilesToLoad","request","url","replace","z","getRequestForTile","promise_default","accept","img","Image","onload","onerror","crossOrigin","src","then","image","drawImage","catch","finally","all","canvasWidth","data","getImageData","windowWidth","windowHeight","allHeights","Float32Array","done","timeQuota","lastY","collectHeights","startTime","index","getHeight","resolve","lngLat","pointLocation","xTile","l","lng2tile","lng","xOffset","yTile","PI","log","tan","cos","lat2tile","lat","yOffset","yC","xC","R","G","B","decodeHeight","visibleHeights","api","undefined","completed","MapboxGeocoder","require","bind","__webpack_require__","oe","heightMapRenderer","regionBuilder","progressHandle","hideHeights","clearTimeout","querySelector","updateMap","heightMapCanvas","setTimeout","display","init","mapboxgl","accessToken","Map","trackResize","container","minZoom","center","zoom","hash","addControl","NavigationControl","showCompass","on","once","getBearing","dragRotate","disable","touchZoomRotate","disableRotation","redraw"],"mappings":"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","file":"static/js/app.d88329b0fc99908f9ba6.js","sourcesContent":["// const ratio = 540/230 - mug\nconst appState = {\n  angle: 0,\n  currentState: 'intro',\n  lineDensity: 28,\n  smoothSteps: 1,\n  mapOpacity: 100,\n  heightScale: 42,\n  oceanLevel: 0,\n  aboutVisible: false,\n  blank: false,\n  error: null,\n  zazzleLink: null,\n  startOver,\n  generatingPreview: false,\n  settingsOpen: false,\n  shouldDraw: false,\n  showPrintMessage: false,\n  renderProgress: null,\n  hidePrintMessageForSession: false,\n  width: window.innerWidth,\n  height: window.innerHeight,\n\n  backgroundColor: {\n    r: 255, g: 255, b: 255, a: 1\n  },\n  lineBackground: {\n    r: 255, g: 255, b: 255, a: 1\n  },\n  lineColor: {\n    r: 22, g: 22, b: 22, a: 0.85\n  },\n};\n\n// projects lon/lat into current XY plane\n\nfunction startOver() {\n  appState.zazzleLink = null;\n  appState.generatingPreview = false;\n  appState.currentState = 'intro';\n  appState.blank = false,\n  appState.downloadOsmProgress = null;\n}\n\nexport default appState;\n\n\n// WEBPACK FOOTER //\n// ./src/appState.js","/**\n * This is the core component of the website which renders lines on the overlay\n * layer\n * @param {*} appState - @see ../appState.js\n * @param {*} map  - mapbox map instance\n * @param {*} canvas  - where the lines should be rendered\n */\nexport default function createHeightMapRenderer(appState, regionInfo, canvas) {\n  let renderHandle;\n\n  render();\n\n  return {\n    /**\n     * When new render request is created, we have to cancel the current one:\n     */\n    cancel,\n    render\n  }\n\n  function render() {\n    // let's set everything up to match our application state:\n    if (appState.renderProgress) {\n      appState.renderProgress.message = 'Rendering...'\n    }\n\n    const oceanLevel = Number.parseFloat(appState.oceanLevel);\n\n    let smoothSteps = parseFloat(appState.smoothSteps);\n\n    canvas.style.opacity = appState.mapOpacity/100;\n\n    let ctx = canvas.getContext('2d');\n    let lineStroke = getColor(appState.lineColor);\n    let lineFill = getColor(appState.lineBackground);\n\n    let resHeight = window.innerHeight;\n    let resWidth = window.innerWidth;\n    let rowCount = Math.round(resHeight * appState.lineDensity/100); \n    let scale = appState.heightScale;\n\n    // since tiles can be partially overlapped, we use our own iterator\n    // over partially overlapped tiles (to not deal with offset math here)\n    const {minHeight, maxHeight, rowWithHighestPoint} = regionInfo.getAllHeightData();\n    const iteratorSettings = createRegionIterator(rowCount, resHeight, rowWithHighestPoint);\n\n    // we want the scale be independent from the zoom level, use the distribution\n    // of heights as our scaler:\n    let heightRange = maxHeight - minHeight;\n\n    let lastLine = [];\n    let lastRow = iteratorSettings.start;\n\n    clearScene();\n    renderRows();\n\n    // Public part is over. Below is is just implementation detail\n\n    /**\n     * This renders rows, and stops if allowed time quota is exceeded (making rendering\n     * async, so that we do not freeze the main thread)\n     */\n    function renderRows() {\n      let now = performance.now();\n\n      for (let y = lastRow; y < iteratorSettings.stop; y += iteratorSettings.step) {\n        drawPolyLine(lastLine);\n        lastLine = [];\n\n        for (let x = 0; x < window.innerWidth; ++x) {\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n\n          if (height <= oceanLevel) {\n            drawPolyLine(lastLine);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y + iteratorSettings.step;\n        let elapsed = performance.now() - now;\n        if (elapsed > 200) {\n          renderHandle = requestAnimationFrame(renderRows);\n          return;\n        }\n      }\n\n      drawPolyLine(lastLine);\n\n      appState.renderProgress = null;\n    }\n\n    /**\n     * Draws filled polyline.\n     */\n    function drawPolyLine(points) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      // If line's height is greater than 2 pixels, let's fill it:\n      if (smoothRange.max - smoothRange.min > 2) {\n        ctx.beginPath();\n        ctx.fillStyle = lineFill;\n        ctx.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += 2) {\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n        ctx.lineTo(points[points.length - 2], smoothRange.max);\n        ctx.lineTo(points[0], smoothRange.max);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineStroke;\n      ctx.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n      ctx.stroke();\n    }\n\n    function clearScene() {\n      ctx.beginPath();\n      ctx.clearRect(0, 0, resWidth, resHeight);\n      ctx.fillStyle = getColor(appState.backgroundColor);\n      ctx.fillRect(0, 0, resWidth, resHeight);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(renderHandle)\n    appState.renderProgress = null;\n    appState.showPrintMessage = false;\n  }\n\n  /**\n   * Simple smoothing function with moving averages, augmented with\n   * min/max calculation (don't want to spend more CPU cycles fo min/max)\n   */\n  function getSmoothRange(points, windowSize) {\n    let result = [];\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    let length = points.length / 2;\n    for (let i = 0; i < length; i += 1) {\n      const leftOffset = i - windowSize;\n      const from = leftOffset >= 0 ? leftOffset : 0\n      const to = i + windowSize + 1;\n\n      let count = 0\n      let sum = 0\n      for (let j = from; j < to && j < length; j += 1) {\n        sum += points[2 * j + 1]\n        count += 1\n      }\n\n      let smoothHeight = sum / count;\n      result[2 * i] = points[2 * i];\n      result[2 * i + 1] = smoothHeight;\n\n      if (max < smoothHeight) max = smoothHeight;\n      if (min > smoothHeight) min = smoothHeight;\n    }\n\n    return {\n      points: result,\n      min,\n      max\n    };\n  }\n\n  /**\n   * Iterate over height map.\n   */\n  function createRegionIterator(rowCount, resHeight, includeRowIndex) {\n    let stepSize = Math.round(resHeight / rowCount);\n\n    return {\n      start: includeRowIndex - Math.floor(includeRowIndex/stepSize) * stepSize,\n      step: stepSize,\n      stop: resHeight\n    }\n  }\n\n  function getColor(color) {\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createHeightMapRenderer.js","export const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW52YWthIiwiYSI6ImNqaWUzZmhqYzA1OXMza213YXh2ZzdnOWcifQ.t5yext53zn1c9Ixd7Y41Dw';\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","import { MAPBOX_TOKEN } from \"./config\";\n\nconst apiURL = `https://api.mapbox.com/v4/mapbox.terrain-rgb/zoom/tLong/tLat@2x.pngraw?access_token=${MAPBOX_TOKEN}`;\n\nexport function loadImage(url) {\n  return new Promise((accept, error) => {\n    const img = new Image();\n    img.onload = () => {\n      accept(img);\n    };\n    img.onerror = error;\n    img.crossOrigin = \"anonymous\";\n    img.src = url;\n  });\n}\n\nfunction getTilesBounds(tiles) {\n  return tiles.reduce((bounds, tile) => {\n    let p = tile.canonical;\n    if (bounds.minX > p.x) bounds.minX = p.x;\n    if (bounds.minY > p.y) bounds.minY = p.y;\n    if (bounds.maxX < p.x) bounds.maxX = p.x;\n    if (bounds.maxY < p.y) bounds.maxY = p.y;\n\n    return bounds;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  })\n}\n\nexport function getRegionElevation(map, progress, doneCallback) {\n  if (!progress) progress = {};\n\n  const renderHD = true;\n\n  const tileSize = renderHD ? 512 : 256;\n  const tileZoom = map.transform.tileZoom;\n  const zoomPower = Math.pow(2, tileZoom);\n\n  const coveringTiles = map.transform.coveringTiles({\n    minzoom: tileZoom,\n    maxzoom: tileZoom,\n    tileSize\n  });\n\n  const tileBounds = getTilesBounds(coveringTiles);\n\n  const canvas = document.createElement(\"canvas\");\n  const width = tileBounds.maxX - tileBounds.minX;\n  const height = tileBounds.maxY - tileBounds.minY;\n  if (width > 50 || height > 50) throw new Error('Too many tiles requested. How did you do it?');\n\n  canvas.width = width * tileSize + tileSize;\n  canvas.height = height * tileSize + tileSize;\n  const ctx = canvas.getContext('2d');\n\n  const minX = tileBounds.minX;\n  const minY = tileBounds.minY;\n\n  progress.total = coveringTiles.length;\n\n  advanceProgress();\n\n  let heightsHandle;\n  let isCancelled = false;\n  const tilesToLoad = coveringTiles.map(toLoadedTile);\n\n  Promise.all(tilesToLoad)\n    .then(computeVisibleHeights)\n    .then(createAPI)\n    .then(api => {\n      if (!isCancelled) {\n        doneCallback(api)\n      }\n    });\n\n  return {\n    cancel() {\n      isCancelled = true;\n      cancelAnimationFrame(heightsHandle);\n    }\n  }\n\n  function createAPI(visibleHeights) {\n    let width = visibleHeights.windowWidth;\n    let data = visibleHeights.allHeights;\n\n    return {\n      getHeightAtPoint,\n      getAllHeightData() {\n        return visibleHeights;\n      }\n    };\n\n    function getHeightAtPoint(x, y) {\n      return data[x + y * width];\n    }\n  }\n\n  function computeVisibleHeights() {\n    const canvasWidth = canvas.width;\n    const data = ctx.getImageData(0, 0, canvasWidth, canvas.height).data;\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    let allHeights = new Float32Array(windowWidth * windowHeight);\n    let done;\n\n    let timeQuota = 16;\n    let minHeight = Infinity;\n    let maxHeight = -Infinity;\n    let rowWithHighestPoint = -1;\n    let lastY = 0;\n    heightsHandle = requestAnimationFrame(collectHeights); // todo let it be cancelled;\n\n    return new Promise((resolve) => { done = resolve });\n\n    function collectHeights() {\n      let startTime = window.performance.now();\n      for (let y = lastY; y < windowHeight; ++y) {\n        for (let x = 0; x < windowWidth; ++x) {\n          const index = y * windowWidth + x;\n          const height = getHeight(x, y);\n          allHeights[index] = height;\n          if (height < minHeight) minHeight = height;\n          if (height > maxHeight) {\n            maxHeight = height;\n            rowWithHighestPoint = y;\n          }\n        }\n        let elapsed = window.performance.now() - startTime;\n        if (elapsed > timeQuota) {\n          if (!isCancelled) heightsHandle = requestAnimationFrame(collectHeights);\n          return;\n        }\n        lastY = y;\n      }\n\n      done({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n    }\n\n    function getHeight(x, y) {\n      let lngLat = map.transform.pointLocation({x, y})\n\n      let xTile = lng2tile(lngLat.lng, zoomPower);\n      let xOffset = (xTile - minX) * tileSize;\n      let yTile = lat2tile(lngLat.lat, zoomPower);\n      let yOffset = (yTile - minY) * tileSize;\n      let yC = Math.round(yOffset);\n      let xC = Math.round(xOffset);\n\n      let index = (yC * canvasWidth + xC) * 4;\n      let R = data[index + 0];\n      let G = data[index + 1];\n      let B = data[index + 2];\n\n      return decodeHeight(R, G, B)\n    }\n\n    function decodeHeight(R, G, B) {\n      let height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)\n      if (height < -100) {\n        // Fiji islands data has huge caves, which pushes the entire thing up.\n        // I'm reducing it.\n        height = height / 5000;\n      }\n      return height;\n    }\n  }\n\n  function toLoadedTile(tile) {\n    const request = getRequestForTile(tile);\n\n    return loadImage(request.url)\n      .then(drawTileImage)\n      .catch(drawBlankTile)\n      .finally(advanceProgress);\n\n    function drawTileImage(image) {\n      ctx.drawImage(image, request.x, request.y);\n    }\n\n    function drawBlankTile() {\n      ctx.beginPath();\n      ctx.fillStyle = '#0186a0'; // zero height\n      ctx.fillRect(request.x, request.y, tileSize, tileSize);\n    }\n  }\n\n  function getRequestForTile(tile) {\n    const p = tile.canonical;\n    const url = apiURL\n      .replace('zoom', p.z)\n      .replace('tLat', p.y)\n      .replace('tLong', p.x);\n\n    return {\n      url,\n      x: tileSize * (p.x - tileBounds.minX), \n      y: tileSize * (p.y - tileBounds.minY)\n    }\n  }\n\n  function advanceProgress() {\n    if (progress.completed === undefined) {\n      progress.completed = -1;\n    }\n    progress.completed = Math.min(progress.total, progress.completed + 1);\n    progress.message = `Downloading tiles: ${progress.completed} of ${progress.total}...`\n  }\n  \n}\n\nexport function lng2tile(l, zoomPower) {\n  let result = ((l + 180) / 360) * zoomPower;\n  return result;\n}\n\nexport function lat2tile(l, zoomPower) {\n  let angle = l * Math.PI / 180;\n  return (\n    ((1 - Math.log( Math.tan(angle) + 1 / Math.cos(angle)) /\n        Math.PI) /\n      2) * zoomPower \n  );\n}\n\nexport function tile2long(x, zoomPower) {\n  return (x / zoomPower) * 360 - 180;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/elevation.js","/**\n * This is the website startup point.\n */\nimport appState from \"./appState\";\nimport mapboxgl from \"mapbox-gl\";\nimport createHeightMapRenderer from \"./lib/createHeightMapRenderer\";\nimport { MAPBOX_TOKEN } from \"./config\";\nimport { getRegionElevation } from './elevation';\n\nvar MapboxGeocoder = require(\"@mapbox/mapbox-gl-geocoder\");\n\n// Load vue asyncronously\nrequire.ensure(\"@/vueApp.js\", () => {\n  require(\"@/vueApp.js\");\n});\n\n// Hold a reference to mapboxgl instance.\nlet map;\nlet heightMapRenderer;\nlet regionBuilder;\nlet progressHandle;\n\n// Let the vue know what to call to start the app.\nappState.init = init;\nappState.redraw = redraw;\nappState.updateMap = updateMap;\n\nfunction init() {\n  mapboxgl.accessToken = MAPBOX_TOKEN;\n\n  window.map = map = new mapboxgl.Map({\n    trackResize: true,\n    container: \"map\",\n    minZoom: 0,\n    style: \"mapbox://styles/mapbox/light-v10\",\n    center: [-122.574, 47.727],\n    zoom: 7.68,\n    hash: true\n  });\n\n  map.addControl(\n    new mapboxgl.NavigationControl({ showCompass: false }),\n    \"bottom-right\"\n  );\n  map.addControl(new MapboxGeocoder({ accessToken: mapboxgl.accessToken }));\n  map.on('moveend', function() {\n    map.once('idle', updateMap)\n  });\n  map.on(\"movestart\", hideHeights);\n  map.on(\"load\", function() {\n    appState.angle = map.getBearing();\n    // map.showTileBoundaries = true;\n  });\n\n  map.dragRotate.disable();\n  map.touchZoomRotate.disableRotation();\n}\n\nfunction hideHeights() {\n  clearTimeout(progressHandle);\n  appState.zazzleLink = null;\n  let canvas = document.querySelector(\".height-map\");\n  if (canvas) canvas.style.opacity = 0.02;\n}\n\nfunction redraw() {\n  if (!heightMapRenderer) return;\n  heightMapRenderer.cancel();\n  heightMapRenderer.render();\n}\n\nfunction updateMap() {\n  if (!map) return;\n\n  let heightMapCanvas = document.querySelector(\".height-map\");\n  if (!heightMapCanvas) return;\n\n  if (heightMapRenderer) {\n    heightMapRenderer.cancel();\n  }\n  if (regionBuilder) {\n    regionBuilder.cancel();\n  }\n\n  clearTimeout(progressHandle);\n\n  progressHandle = setTimeout(function() {\n    appState.showPrintMessage = true;\n  }, 10000)\n\n  if (!appState.shouldDraw) {\n    heightMapCanvas.style.display = \"none\";\n    return;\n  } else {\n    heightMapCanvas.style.display = \"\";\n  }\n  \n  appState.showPrintMessage = false;\n  appState.renderProgress = {\n    message: '',\n    isCancelled: false,\n    completed: false\n  };\n\n  // This will fetch all heightmap tiles\n  regionBuilder = getRegionElevation(map, appState.renderProgress, showRegionHeights)\n\n  function showRegionHeights(regionInfo) {\n    heightMapRenderer = createHeightMapRenderer(appState, regionInfo, heightMapCanvas);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}